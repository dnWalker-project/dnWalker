<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="dnWalker.Parameters" #>
<#@ import namespace="dnWalker.TestGenerator.Reflection" #>
// This file was generated by dnWalker.TestGenerator tool <#= DateTime.Now.ToString("dd/MM/yyyy - HH:mm:ss") #>

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

using FluentAssertions;

using Xunit;

using Microsoft.VisualStudio.TestTools.UnitTesting.PrivateObject;

namespace <#= TestData.TestNamespaceName #>
{
    public class <#= TestData.TestClassName #>
    {

        public <#= TestData.TestClassName #>()
        {
            //TODO: if necessary initialize environment hooks (todo in base class?), something to catch console output etc.
        }
<# // generate a fact test for each iteration
foreach(ExplorationIterationData iterationData in TestData.ExplorationData.Iterations)
{
    WriteTestMethod(iterationData);
}
#>

<# // generate initialization methods 
WriteObjectInitializationMethods();
#>
    }
}

<#+ 
// generate initialization methods
private void WriteObjectInitializationMethods()
{
    // pass through each iteration data input parameters & find out what fields are specified

    Dictionary<string, HashSet<string>> initializedFields = new Dictionary<string, HashSet<string>>();

    foreach (ExplorationIterationData iterationData in TestData.ExplorationData.Iterations)
    {
        foreach (ObjectParameter objectParameter in iterationData.ParameterStore.GetAllParameters().OfType<ObjectParameter>())
        {
            foreach (string fieldName in objectParameter.GetKnownFields().Select(p => p.Key))
            {
                if (!initializedFields.TryGetValue(objectParameter.TypeName, out HashSet<string>? fields))
                {
                    fields = new HashSet<string>();
                    initializedFields[objectParameter.TypeName] = fields;
                }

                fields.Add(fieldName);
            }
        }
    }

    foreach (KeyValuePair<string, HashSet<string>> typeFields in initializedFields)
    {
        WriteObjectInitializationMethod(typeFields.Key, typeFields.Value);
    }
}
#>

<#+ 
// generate a single initialize object method
private void WriteObjectInitializationMethod(string fullTypeName, IEnumerable<string> fieldsToInitialize)
{
    // using this method, because for Type.GetType(string) full type name and assembly name is needed.
    Type type = AppDomain.CurrentDomain.GetType(fullTypeName) ?? throw new ArgumentException("Cannot find specified type.");

    List<KeyValuePair<string, Type>> fieldInfos = fieldsToInitialize
            .Where(f => f != ReferenceTypeParameter.IsNullName && f != ArrayParameter.LengthName)
            .Select(f => KeyValuePair.Create(f, type.GetField(f)?.FieldType ?? throw new Exception("Cannot find specified field.")))
            .ToList();
#>
        public static <#= type.Name #> Initialize_<#= type.Name #>(<#+ 
        
        for (int i = 0; i < fieldInfos.Count; ++i)
        {
            KeyValuePair<string, Type> f = fieldInfos[i];
            #><#= f.Value.Name #> value_<#= f.Key #> = <#+ WriteDefaultValue(f.Value);

            if (i < fieldInfos.Count - 1)
            {
                #>, <#+
            }
        }
        #>)
        {
<#+ // create instance of the initialized object, TODO: based on whether default constructor exists, chose between new() and external, user-defined method #>
            <#= type.Name #> <#= type.Name #>_instance = new <#= type.Name #>();

<#+ // create private object instance to set the fields #>
            PrivateObject po = new PrivateObject(<#= type.Name #>_instance);
            
<#+ // set all field to the values provided via arguments 
        foreach (string fieldName in fieldInfos.Select(p => p.Key))
        {
#>
            po.SetField("<#= fieldName #>", value_<#= fieldName #>);
<#+
        }
#>
            return <#= type.Name #>_instance;
        }
<#+
}
#>

<#+ // generate a single fact test method
private void WriteTestMethod(ExplorationIterationData iterationData)
{
#>

        [Fact]
        public void Test_<#= TestData.SUTMethod.Name #>_<#= iterationData.IterationNumber #>()
        {
            // TODO: initialize environment (static members etc)
            // initialize method args
<#+
    MethodInfo sutMethod = TestData.SUTMethod;
    Type sutType = TestData.SUTType;
    ParameterStore parameters = iterationData.ParameterStore;

    foreach (ParameterInfo pi in sutMethod.GetParameters())
    {
        string pName = pi.Name!;
        Type pType = pi.ParameterType;

        WriteVariableInitialization(pType, pName == ParameterStore.ThisParameterName ? "sutInstance" : pName, pName, parameters);
    }
#>          

            // TODO: initialize expected result environment (standard output...)
            // TODO: initialize expected result
<#+
    // create args string
    string methodArgsString = string.Join(", ", sutMethod.GetParameters().Select(pi => pi.Name));

    // invoke the method
    if (sutMethod.IsStatic)
    {
        if (sutMethod.ReturnType == typeof(void))
        {
#>

            // invoke the method itself
            <#= sutType.Name #>.<#= sutMethod.Name #>(<#= methodArgsString #>);
<#+
        }
        else
        {

            // initialize expected result
            WriteVariableInitialization(sutMethod.ReturnType, "expectedResult", ParameterStore.ResultParameterName, parameters);

#>

            // invoke the method itself
            <#= sutMethod.ReturnType.Name #> result = <#= sutType.Name #>.<#= sutMethod.Name #>(<#= methodArgsString #>);

            // assert result and expected result
            result.Should().Be(expectedResult);
<#+
        }
    }
    else // TODO: find out how the signature for instance method should work, e.g. whether "hidden this" is one of the parameters or not...
    {
    }
#>
        }
<#+
}
#>
<#+  
private void WriteVariableInitialization(Type variableType, string variableName, string parameterName, ParameterStore store)
{
    if (store.TryGetParameter(parameterName, out Parameter parameter))
    {
#>
            <#= variableType.Name #> <#= variableName #> = <#+ WriteRightHandParameterInitialization(parameter); #>;
<#+
    }
    else
    {
        // parameter will be initialized as default
#>
            <#= variableType.Name #> <#= variableName #> = <#+ WriteDefaultValue(variableType); #>;
<#+
     }
}
#>

<#+ 
private void WriteRightHandParameterInitialization(Parameter p)
{
    PushIndent("    ");
    switch(p)
    {
        case PrimitiveValueParameter primitiveValue:
            WriteRightHandParameterInitialization(primitiveValue);
            break;

        case ObjectParameter objectParameter:
            WriteRightHandParameterInitialization(objectParameter);
            break;
    }
    PopIndent();
}

private void WriteRightHandParameterInitialization(PrimitiveValueParameter p)
{
    Type type = AppDomain.CurrentDomain.GetType(p.TypeName);

    object value = p.GetValue();
    if (value != null)
    {
        #><#= value.ToString() #><#+
    }
    else
    {
        WriteDefaultValue(type);
    }
}

private void WriteRightHandParameterInitialization(ObjectParameter p)
{
    Type type = AppDomain.CurrentDomain.GetType(p.TypeName);

    if (p.IsNull)
    {
        // initialize as null
        #>null<#+
    }
    else
    {
        // we will invoke the initialize method
        List<KeyValuePair<string, Parameter>> fields = p.GetKnownFields().ToList();
        if (fields.Count == 0)
        {
            // now fields to initialize, just invoke the method without any arguments
            #>Initialize_<#= type.Name #>()<#+
        }
        else
        {
            // initialize each field, recursively on its own line
            #>Initialize_<#= type.Name #>
        (
<#+ 
            for (int i = 0; i < fields.Count; ++i)
            {
                KeyValuePair<string, Parameter> field = fields[i];
#>
            value_<#= field.Key #>: <#+ WriteRightHandParameterInitialization(field.Value);
                if (i < fields.Count - 1)
                {
                    #>, <#+
                }
                WriteLine("");
            }
#>
        )<#+
        }
    }
}
#>

<#+ 
private void WriteDefaultValue(Type type)
{
    if (!type.IsValueType)
    {
        #>null<#+
    }
    else
    {
        switch(Type.GetTypeCode(type))
        {
            case TypeCode.Byte:
            case TypeCode.SByte:
            case TypeCode.UInt16:
            case TypeCode.UInt32:
            case TypeCode.UInt64:
            case TypeCode.Int16:
            case TypeCode.Int32:
            case TypeCode.Int64:
            case TypeCode.Decimal:
            case TypeCode.Double:
            case TypeCode.Single:
        #>0<#+
              break;
            default:
        #>default(<#= type.Name #>)<#+
              break;
        }
    }
}
#>