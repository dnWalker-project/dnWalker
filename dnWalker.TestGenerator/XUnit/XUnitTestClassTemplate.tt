<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="dnWalker.Parameters" #>
<#@ import namespace="dnWalker.TestGenerator.Reflection" #>
// This file was generated by dnWalker.TestGenerator tool <#= DateTime.Now.ToString("dd/MM/yyyy - HH:mm:ss") #>
<#
	// TODO: get nullable status from TestData 
#>
#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

using FluentAssertions;

using Xunit;

<# 
	// setup custom tool for accessing private fields - cannot access base class fields... https://github.com/cactuaroid/PrivateObjectExtensions ?
#>
using Moq;

namespace <#= TestData.TestNamespaceName #>
{
	public class <#= TestData.TestClassName #>
	{
		#region Test Methods
<#
	foreach (var iteration in TestData.ExplorationData.Iterations)
	{
#>

		[Fact]
		public void Test_Iteration_<#= iteration.Number #>()
		{
			// construct all input parameters which are used in the test
			// TODO: construct return value comparer instance
<#
		List<IObjectParameter> objectsToInitialize = new List<IObjectParameter>();
		List<IArrayParameter> arraysToInitialize = new List<IArrayParameter>();
		IParameterContext startingCtx = iteration.StartingParameterContext;
		IParameterContext endingCtx = iteration.EndingParameterContext;

		foreach (var keyValue in startingCtx.Parameters)
		{
			if (keyValue.Value is IPrimitiveValueParameter pv)
			{
#>
			<#= pv.Type #> <#= GetVariableName(keyValue.Value) #> = <# if (pv.Value != null) { #><#= pv.Value.GetType() == typeof(bool) ? pv.Value.ToString().ToLower() : pv.Value #><# } else { #> default(<#= pv.Type #>) <# }#>;
<#
			}
			else if (keyValue.Value is IObjectParameter op)
			{
				
#>
			<#= op.Type #>? <#= GetVariableName(keyValue.Value) #> = <# if (!op.GetIsNull()) { objectsToInitialize.Add(op); #>Create_<#= keyValue.Key #>(out Mock<<#= op.Type #>> methodsMock_<#= keyValue.Key #>)<# } else {  #>null<# } #>;
<#
			}
			else if (keyValue.Value is IArrayParameter ap)
			{
#>
			<#= ap.ElementType #>[]? <#= GetVariableName(keyValue.Value) #> = <# if (!ap.GetIsNull()) { arraysToInitialize.Add(ap); #>Create_<#= keyValue.Key #>(<#= ap.GetLength() #>)<# } else {  #>null<# } #>;
<#
			}
			else
			{
				// 
			}
#>
			
<#
		}
#>
			// initialize all parameters which needs initialization
			// TODO: initialize return value comparer instance
			
<#
		foreach (var op in objectsToInitialize)
		{
			int i = op.GetFields().Count;
			if (i > 0)
			{

#>
			InitializeFields_<#= op.Reference #>
			(
				<#= GetVariableName(op.Reference, startingCtx) #>,
<#
				foreach (var fi in op.GetFields())
				{
					--i;
#>
				arg_<#= fi.Key #>: <#= GetVariableName(fi.Value, startingCtx) #> <#= i > 0 ? "," : "" #>
<#
				}
#>
			);

<#
			}

			KeyValuePair<MethodSignature, ParameterRef[]>[] results = op.GetMethodResults().Where(p => p.Value.Length > 0 && !p.Value.All(r => r == ParameterRef.Empty)).ToArray();

			i = results.Length;
			if (i > 0)
			{
#>
			InitializeMethods_<#= op.Reference #>
			(
				methodsMock_<#= op.Reference #>,
<#
				foreach (var mi in results)
				{
					--i;
#>
				arg_<#= mi.Key.MethodName #>: new <#= mi.Key.ReturnTypeFullName #>[] { <# 
					
					int j = mi.Value.Length;
					foreach (var r in mi.Value)
					{
						--j;
						if (r == ParameterRef.Empty)
						{
#> default(<#= mi.Key.ReturnTypeFullName #>)<#= j > 0 ? "," : "" #><#
						}
						else
						{
#> <#= GetVariableName(r, startingCtx) #><#= j > 0 ? "," : "" #><#
						}
					}

#> } <#= i > 0 ? "," : "" #>
<#
				}
#>
			);
<#
			}
		}

		foreach (var ap in arraysToInitialize)
		{
			int i = ap.GetItems().Length;
			if (i > 0)
			{
#>
			InitializeItems_<#= ap.Reference #>
			(
				<#= GetVariableName(ap.Reference, startingCtx) #>,
<#
				foreach (var item in ap.GetItems())
				{
					--i;
					if (item == ParameterRef.Empty)
					{
#>
				default(<#= ap.ElementType #>)<#= i > 0 ? "," : "" #>
<#
					}
					else
					{
#>
				<#= GetVariableName(item, startingCtx) #><#= i > 0 ? "," : "" #>
<#
					}
				}
#>
			);
<#
			}
		}
#>
			// execute the tested method
			// TODO: make assert for method exception
			// TODO: make assert for method return values
			// TODO: handle instance methods
<#
		if (TestData.SUTMethod.IsStatic)
		{
			if (TestData.SUTMethod.ReturnType == typeof(void))
			{
#>
			<#= TestData.SUTType.FullName #>.<#= TestData.SUTMethod.Name #>(<#= BuildExecutionArgs(TestData.SUTMethod, startingCtx) #>);
<#
			}
			else
			{
#>
			var result = <#= TestData.SUTType.FullName #>.<#= TestData.SUTMethod.Name #>(<#= BuildExecutionArgs(TestData.SUTMethod, startingCtx) #>);
<#
			}
		}
#>

			// construct all output parameters which are used in the test
			// 1. ret val if exists
<#
			if (TestData.SUTMethod.ReturnType != typeof(void))
			{
				if (endingCtx.Roots.TryGetValue("RetVal", out ParameterRef retValueRef))
				{
					IParameter retParamter = retValueRef.Resolve(endingCtx);

					if (retParamter is IPrimitiveValueParameter pv)
					{
#>
			<#= pv.Type #>  retValue = <# if (pv.Value != null) { #><#= pv.Value.GetType() == typeof(bool) ? pv.Value.ToString().ToLower() : pv.Value #><# } else { #> default(<#= pv.Type #>) <# }#>;
			Assert.Equal(result, retValue);
<#
					}
					else if (retParamter is IObjectParameter op)
					{
#>
			// <#= op.Type #>? retValue = <# if (!op.GetIsNull()) { objectsToInitialize.Add(op); #>Create_<#= retParamter.Reference #>(out _ <# } else {  #>null<# } #>;
			// TODO: create return value for non primitive values & do as much assertions as possible
<#
					}
					else if (retParamter is IArrayParameter ap)
					{
#>
			// <#= ap.ElementType #>[]? retValue = <# if (!ap.GetIsNull()) { arraysToInitialize.Add(ap); #>Create_<#= retParamter.Reference #>(<#= ap.GetLength() #>)<# } else {  #>null<# } #>;
			// TODO: create return value for non primitive values & do as much assertions as possible
<#
					}

#>

<#
				}
				else
				{
#>
			// ERROR: method has a return type but no return value is specified!!!! Maybe because it returns another parametrized value and the alias parameter is not yet implemented.
<#
				}
			}
#>


		}
<#
	}
#>
		#endregion Test Methods

		#region Parameter Creation Methods
		// these methods constructs instances of parameters along with interfaces for their initialization
<#
	foreach (var keyValue in TestData.Initializations)
	{
		if (keyValue.Value is PrimitiveValueInitializationInfo) 
		{
			// we do not need construction method for primitive values
			continue;
		}

		if (keyValue.Value is ObjectInitializationInfo objectInitialization)
		{
			WriteObjectConstruction(objectInitialization);
		}
		else if (keyValue.Value is ArrayInitializationInfo arrayInitialization)
		{
			WriteArrayConstruction(arrayInitialization);
		}
#>
		
<#
		}
#>


		#endregion Parameter Creation Methods

		#region Parameter Initialization Methods
<#
	// Setup initialization functions for each non-primitive parameter
	foreach (var keyValue in TestData.Initializations)
	{
		if (keyValue.Value is PrimitiveValueInitializationInfo) 
		{
			// we do not need initialization method for primitive values
			continue;
		}
#>
		// initialize parameter <#= keyValue.Key #>
<#
		if (keyValue.Value.Accesses.Count > 0)
		{
			foreach (string access in keyValue.Value.Accesses)
			{
#>
		// - <#= access #>
<#
			}
		}

		if (keyValue.Value is ObjectInitializationInfo objectInitialization)
		{
			WriteObjectIntialization(objectInitialization);
		}
		else if (keyValue.Value is ArrayInitializationInfo arrayIntialization)
		{
			WriteArrayInitialization(arrayIntialization);
		}
#>
<#
	}
#>
		#endregion Parameter Initialization Methods
	}
}

<#+
	// Methods
	private string BuildArgumentsSignature(Type[] argTypes, string[] argNames)
	{
		IEnumerable<string> argDeclarations = argTypes
			//.Select((t, i) => $"{t.FullName} {argNames[i]} = default({t.FullName})");
			.Select((t, i) => $"{t.FullName} {argNames[i]} = default");

		return string.Join(", ", argDeclarations);
	}	

	private string BuildAnyMockArguments(MethodInfo method)
	{
		IEnumerable<string> args = method.GetParameters().Select(p => $"It.IsAny<{p.ParameterType.FullName}>()");

		return string.Join(", ", args);
	}
#>
<#+
	private void WriteObjectConstruction(ObjectInitializationInfo objectInitialization)
	{

		string instanceType = objectInitialization.ExpectedType.FullName;
		
		// add possibility to override construction?? how exactly?
#>
		private <#= instanceType #> Create_<#= objectInitialization.Reference #>(out Mock<<#= instanceType #>> methodsMock)
		{
			methodsMock = new Mock<<#= instanceType #>>();
			var instance = methodsMock.Object;
			return instance;
		}
<#+
	}
#>
<#+
	private void WriteObjectIntialization(ObjectInitializationInfo objectInitialization)
	{
		// we need to write the initialization method signature
		// we know which fields we want to use and which method we want to mock

		string instanceType = $"{objectInitialization.ExpectedType.FullName}";
		string instanceName = $"instance_{objectInitialization.Reference}";

		if (objectInitialization.UsedFields.Count > 0)
		{
			Type[] argTypes = objectInitialization.UsedFields.Select(fi => fi.FieldType).ToArray();
			string[] argNames = objectInitialization.UsedFields.Select(fi => "arg_" + fi.Name).ToArray();
#>
		private void InitializeFields_<#= objectInitialization.Reference #>(<#= objectInitialization.ExpectedType.FullName #> instance, <#= BuildArgumentsSignature(argTypes, argNames) #>)
		{
			// initialize field using private object
<#+
			foreach (var fi in objectInitialization.UsedFields)
			{
				string fieldName = fi.Name;
#>
			instance.SetPrivate("<#= fieldName #>", arg_<#= fieldName #>);
<#+
			}
#>
		}
<#+
		}

		if (objectInitialization.InvokedMethods.Count > 0)
		{
			var methods = objectInitialization.InvokedMethods.Where(p => p.Value >= 1).Select<KeyValuePair<MethodInfo, int>, (MethodInfo method, string arg)>(p => (p.Key, "arg_" + p.Key.Name)).ToArray();

			Type[] argTypes = methods.Select(m => m.method.ReturnType.MakeArrayType()).ToArray();
			string[] argNames = methods.Select(m => m.arg).ToArray();
#>
		private void InitializeMethods_<#= objectInitialization.Reference #>(Mock<<#= instanceType #>> mock, <#= BuildArgumentsSignature(argTypes, argNames) #>)
		{
			// TODO: initialize method results to correspond to provided values
			// first invocation returns arg_<MethodName>[0] etc
			// right now, always return first element... :(
<#+
			foreach ((MethodInfo method, string arg) in methods)
			{
				
#>
			mock.Setup(o => o.<#= method.Name #>(<#= BuildAnyMockArguments(method) #>)).Returns(<#= arg #>[0]);
<#+
			}
#>
		}
<#+
		}
	}
#>
<#+
	private void WriteArrayConstruction(ArrayInitializationInfo arrayInitialization)
	{
#>
		private <#= arrayInitialization.ExpectedElementType.FullName #>[] Create_<#= arrayInitialization.Reference #>(int length)
		{
			return new <#= arrayInitialization.ExpectedElementType.FullName #>[length];
		}
<#+
	}
#>
<#+
	private void WriteArrayInitialization(ArrayInitializationInfo arrayInitialization)
	{
		// we need to write the initialization method signature
		// we know which fields we want to use and which method we want to mock
#>
		private void InitializeItems_<#= arrayInitialization.Reference #>(<#= arrayInitialization.ExpectedElementType.FullName #>[] array, params <#= arrayInitialization.ExpectedElementType.FullName #>[] items)
		{
			items.CopyTo(array, System.Math.Min(items.Length, array.Length));
		}
<#+
	}
#>
<#+
	private string BuildExecutionArgs(MethodInfo method, IParameterContext context)
	{
		IEnumerable<string> refs = method.GetParameters().Select(p => p.Name);
		return string.Join(", ", refs);
	}
#>
<#+
	private string GetVariableName(ParameterRef reference, IParameterContext context)
	{
		return GetVariableName(reference.Resolve(context));
	}

	private string GetVariableName(IParameter parameter)
	{
		if (parameter.IsRoot(out MethodArgumentParameterAccessor arg))
		{
			return arg.Expression;
		}
		else if (parameter.IsRoot(out ReturnValueParameterAccessor rv))
		{
			return rv.Expression;
		}

		return $"var_{parameter.Reference}";
	}
#>
