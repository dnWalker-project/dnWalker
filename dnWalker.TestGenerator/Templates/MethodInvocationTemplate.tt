<#@ template language="C#" linepragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ output extension=".g.cs" #>
<#@ include file="TypeNameTemplate.tt" once="true" #>
<#@ include file="TemplateHelpers.tt" once="true" #>
<#+
		protected void WriteStaticMethodInvocation(MethodInvocationData data)
		{
			MethodInfo method = data.Method;
            Type declaringType = method.DeclaringType ?? throw new Exception("Cannot access the declaring type!");

			WriteTypeName(declaringType);

			Write(TemplateHelpers.Dot);

			if (method.IsGenericMethod)
			{
                Type[] genericParameters = method.GetGenericArguments();
                Write(method.Name);
				Write("<");
				
				WriteJoint(TemplateHelpers.Coma, genericParameters, WriteTypeName);

				Write(">");
			}
			else
			{
				Write(TemplateHelpers.WithoutGenerics(method.Name));
			}

			Write("(");

			if (data.Arguments.Length > 0)
			{
				WriteJoint(TemplateHelpers.Coma, data.Arguments, a => Write(a.Expression));
			}

			Write(")");
		}
		
		protected void WriteInstanceMethodInvocation(MethodInvocationData data)
		{
			MethodInfo method = data.Method;

			Write(data.Instance);

			Write(TemplateHelpers.Dot);

			if (method.IsGenericMethod)
			{
                Type[] genericParameters = method.GetGenericArguments();
                Write(method.Name);
				Write("<");
				
				WriteJoint(TemplateHelpers.Coma, genericParameters, WriteTypeName);

				Write(">");
			}
			else
			{
				Write(TemplateHelpers.WithoutGenerics(method.Name));
			}

			Write("(");

			if (data.Arguments.Length > 0)
			{
				WriteJoint(TemplateHelpers.Coma, data.Arguments, a => Write(a.Expression));
			}

			Write(")");
		}
#>