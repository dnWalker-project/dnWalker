<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".tt.cs" #>
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

<#
    ExpressionInfo[] exprs = new ExpressionInfo[]
    {
        new ExpressionInfo('V', "ValueOf", false, "IPrimitiveValueParameter"),
        new ExpressionInfo('L', "LengthOf", false, "IArrayParameter", "IAliasParameter"),
        new ExpressionInfo('N', "IsNull", false, "IReferenceTypeParameter", "IAliasParameter"),
        new ExpressionInfo('R', "RefEquals", true, "IReferenceTypeParameter", "IAliasParameter"),
        // new ExpressionInfo('E', "Equals", true), // Do not know if it is necessary...
    };
 #>

namespace dnWalker.Parameters.Expressions
{
    public abstract class ParametricExpression
    {
        public static ParametricExpression Parse(ReadOnlySpan<char> str)
        {
            if (TryParse(str, out ParametricExpression? expression))
            {
                return expression;
            }
            throw new FormatException();
        }
        
        protected abstract char Identifier { get; }

        public static bool TryParse(ReadOnlySpan<char> str, [NotNullWhen(true)] out ParametricExpression? expression)
        {
            expression = null;

            char exprId = str[0];
            
            bool isBinary = str.Length == 17; // 1 + 8 + 8
            bool isUnary = str.Length == 9; // 1 + 8

            if (isBinary && 
                ParameterReference.TryParse(str.Slice(1, 8), out var lhsRef) &&
                ParameterReference.TryParse(str.Slice(9, 8), out var rhsRef))
            {
                switch (exprId)
                {
<#
    foreach(ExpressionInfo info in exprs.Where(i => i.IsBinary))
    {
 #>
                    case '<#= info.Identifier #>':
                        expression = new <#= info.Name #>ParametricExpression(lhsRef, rhsRef);
                        break;
<#
    }
 #>
                }
            }
            else if (isUnary && ParameterReference.TryParse(str.Slice(1,8), out var operand))
            {
                switch (exprId)
                {
<#
    foreach(ExpressionInfo info in exprs.Where(i => !i.IsBinary))
    {
 #>
                    case '<#= info.Identifier #>':
                        expression = new <#= info.Name #>ParametricExpression(operand);
                        break;
<#
    }
 #>
                }
            }

            return expression != null;
        }

<#
    foreach(ExpressionInfo info in exprs.Where(i => !i.IsBinary))
    {
        foreach(string parameterType in info.ParameterTypes)
        {
 #>
        public static <#= info.Name #>ParametricExpression Make<#= info.Name #>(<#= parameterType #> parameter)
        {
            return new <#= info.Name #>ParametricExpression(parameter.Id);
        }
<#
        }
 #>
<#
    }
 #>

<#
    foreach(ExpressionInfo info in exprs.Where(i => i.IsBinary))
    {
        foreach ((string lhsType, string rhsType) in GetDoubles(info.ParameterTypes))
        {
 #>
        public static <#= info.Name #>ParametricExpression Make<#= info.Name#>(<#= lhsType #> lhs, <#= rhsType #> rhs)
        {
            return new <#= info.Name #>ParametricExpression(lhs.Id, rhs.Id);
        }
<#
            if (lhsType != rhsType)
            {
 #>
        public static <#= info.Name #>ParametricExpression Make<#= info.Name#>(<#= rhsType #> lhs, <#= lhsType #> rhs)
        {
            return new <#= info.Name #>ParametricExpression(lhs.Id, rhs.Id);
        }
<#
            }
 #>

<#
        }
 #>
<#
    }
 #>
    }

    public abstract class BinaryParametricExpression : ParametricExpression
    {
        protected BinaryParametricExpression(ParameterReference lhs, ParameterReference rhs)
        {
            Lhs = lhs;
            Rhs = rhs;
        }

        public ParameterReference Lhs { get; }
        public ParameterReference Rhs { get; }

        public override string ToString()
        {
            return $"{Identifier}{Lhs}{Rhs}";
        }
    }

    public abstract class UnaryParametricExpression : ParametricExpression
    {
        protected UnaryParametricExpression(ParameterReference operand)
        {
            Operand = operand;
        }

        public ParameterReference Operand { get; }
        
        public override string ToString()
        {
            return $"{Identifier}{Operand}";
        }
    }

<#
    foreach (ExpressionInfo info in exprs)
    {
        if (info.IsBinary)
        {
 #>
    public class <#= info.Name #>ParametricExpression : BinaryParametricExpression
    {
        public <#= info.Name #>ParametricExpression(ParameterReference lhs, ParameterReference rhs) : base(lhs, rhs)
        {
        }
<#      
        }
        else
        {
 #>
    public class <#= info.Name #>ParametricExpression : UnaryParametricExpression
    {
        public <#= info.Name #>ParametricExpression(ParameterReference operand) : base(operand)
        {
        }
<#
        }
 #>

        internal static readonly char IdChar = '<#= info.Identifier #>';

        protected override char Identifier 
        {
            get { return IdChar; }
        }
    }
<#
    }
 #>
}

<#+
    private readonly struct ExpressionInfo
    {
        public char Identifier { get; }
        public string Name { get; }
        public bool IsBinary { get; }
        public string[] ParameterTypes { get; }

        public ExpressionInfo(char id, string name, bool isBinary, params string[] parameterTypes)
        {
            Identifier = id;
            Name = name;
            IsBinary = isBinary;
            ParameterTypes = parameterTypes;
        }
    }

    private static IEnumerable<(T, T)> GetDoubles<T>(T[] sourceArray)
    {
        for (int i = 0; i < sourceArray.Length; ++i)
        {
            for (int j = i; j < sourceArray.Length; ++j)
            {
                yield return (sourceArray[i], sourceArray[j]);
            }
        }
    }
 #>