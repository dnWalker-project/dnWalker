<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".tt.cs" #>
using dnWalker.Symbolic;

using MMC.Data;
using MMC.InstructionExec;
using MMC.State;

using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace dnWalker.Instructions.Extensions
{
<#
	ConversionInfo[] conversions = new ConversionInfo[]
	{
		new ConversionInfo("CONV_I", "int"),
		new ConversionInfo("CONV_I1", "int"),
		new ConversionInfo("CONV_I2", "int"),
		new ConversionInfo("CONV_I4", "int"),
		new ConversionInfo("CONV_I8", "int"),
		
		new ConversionInfo("CONV_OVF_I", "int"),
		new ConversionInfo("CONV_OVF_I_UN", "int"),
		new ConversionInfo("CONV_OVF_I1", "int"),
		new ConversionInfo("CONV_OVF_I1_UN", "int"),
		new ConversionInfo("CONV_OVF_I2", "int"),
		new ConversionInfo("CONV_OVF_I2_UN", "int"),
		new ConversionInfo("CONV_OVF_I4", "int"),
		new ConversionInfo("CONV_OVF_I4_UN", "int"),
		new ConversionInfo("CONV_OVF_I8", "int"),
		new ConversionInfo("CONV_OVF_I8_UN", "int"),
		
		new ConversionInfo("CONV_OVF_U", "int"),
		new ConversionInfo("CONV_OVF_U_UN", "int"),
		new ConversionInfo("CONV_OVF_U1", "int"),
		new ConversionInfo("CONV_OVF_U1_UN", "int"),
		new ConversionInfo("CONV_OVF_U2", "int"),
		new ConversionInfo("CONV_OVF_U2_UN", "int"),
		new ConversionInfo("CONV_OVF_U4", "int"),
		new ConversionInfo("CONV_OVF_U4_UN", "int"),
		new ConversionInfo("CONV_OVF_U8", "int"),
		new ConversionInfo("CONV_OVF_U8_UN", "int"),

		new ConversionInfo("CONV_R_UN", "double"),
		new ConversionInfo("CONV_R4", "double"),
		new ConversionInfo("CONV_R8", "double"),
		
		new ConversionInfo("CONV_U", "int"),
		new ConversionInfo("CONV_U1", "int"),
		new ConversionInfo("CONV_U2", "int"),
		new ConversionInfo("CONV_U4", "int"),
		new ConversionInfo("CONV_U8", "int"),
	};
#>

	public static partial class Extensions
	{
		public static ExtendableInstructionFactory AddSymbolicConversionExecution(this ExtendableInstructionFactory factory)
		{

<#
	foreach(ConversionInfo conversion in conversions)
	{
#>
			factory.RegisterExtension(new <#= conversion.Instruction #>_SymbolicExecutionExtension());
<#
	}
#>
			return factory;
		}
	}

	public abstract class SymbolicConversionExtensionBase : IPreExecuteInstructionExtension, IPostExecuteInstructionExtension
	{

        public abstract IEnumerable<Type> SupportedInstructions
        {
            get;
        }

		public abstract Type ResultType 
		{
			get; 
		}

		private INumericElement _operand;


        public void PreExecute(InstructionExecBase instruction, ExplicitActiveState cur)
        {
            IDataElement toPop = cur.EvalStack.Peek();
            _operand = (toPop is IManagedPointer) ? (toPop as IManagedPointer).ToInt4() : (INumericElement)toPop;
        }

        public void PostExecute(InstructionExecBase instruction, ExplicitActiveState cur, IIEReturnValue retValue)
        {
            IDataElement target = cur.EvalStack.Peek();

            if (_operand.TryGetExpression(cur, out Expression expression))
            {
                Type outType = ResultType;
                if (expression.Type == outType)
                {
                    target.SetExpression(expression, cur);
                }
                else
                {
                    target.SetExpression(instruction.CheckOverflow ? Expression.ConvertChecked(expression, outType) : Expression.Convert(expression, outType), cur);
                }
            }
        }
	}
<#
	foreach(ConversionInfo conversion in conversions)
	{
#>
	public class <#= conversion.Instruction #>_SymbolicExecutionExtension : SymbolicConversionExtensionBase
	{
		private static readonly Type[] _instructions = new Type[]
		{
			 typeof(<#= conversion.Instruction #>)
		};

		public override IEnumerable<Type> SupportedInstructions
        {
            get
			{
				return _instructions;
			}
        }

		public override Type ResultType
		{
			get
			{
				return typeof(<#= conversion.OutputType #>);
			}
		}
	}
<#
	}
#>
}

<#+
	private readonly struct ConversionInfo
	{
		public ConversionInfo(string instruction, string outputType)
		{
			Instruction = instruction;
			OutputType = outputType;
		}

		public string Instruction { get; }
		public string OutputType { get; }

	}
#>
