<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".tt.cs" #>
using dnlib.DotNet.Emit;

using dnWalker.Symbolic;

using MMC.Data;
using MMC.InstructionExec;
using MMC.State;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace dnWalker.Instructions.Extensions
{
    public abstract class SymbolicBinaryExecutionExtension : IPreExecuteInstructionExtension, IPostExecuteInstructionExtension
    {
        public abstract IEnumerable<Type> SupportedInstructions { get; }

        /// <summary>
        /// Gets the expression type which is created by this extension.
        /// </summary>
        public abstract ExpressionType ExpressionType { get; }

        private IDataElement _lhs;
        private IDataElement _rhs;

        protected IDataElement Lhs
        {
            get { return _lhs; }
        }
        
        protected IDataElement Rhs
        {
            get { return _rhs; }
        }

        public virtual void PreExecute(InstructionExecBase instruction, ExplicitActiveState cur)
        {
            _rhs = cur.EvalStack[cur.EvalStack.Length - 1];
            _lhs = cur.EvalStack[cur.EvalStack.Length - 2];
        }


        public virtual void PostExecute(InstructionExecBase instruction, ExplicitActiveState cur, IIEReturnValue retValue)
        {
            if (IsSymbolic(cur, out Expression lhsExpr, out Expression rhsExpr))
            {
                IDataElement result = cur.EvalStack.Peek();

                result.SetExpression(Expression.MakeBinary(ExpressionType, lhsExpr, rhsExpr), cur);
            }
        }

        protected virtual bool IsSymbolic(ExplicitActiveState cur, out Expression lhsExpr, out Expression rhsExpr)
        {
            bool isLhsSymbolic = _lhs.TryGetExpression(cur, out lhsExpr);
            bool isRhsSymbolic = _rhs.TryGetExpression(cur, out rhsExpr);

            if (isRhsSymbolic || isLhsSymbolic)
            {
                lhsExpr ??= _lhs.AsExpression();
                rhsExpr ??= _rhs.AsExpression();

                return true;
            }

            return false;
        }
    }
    
    public abstract class SymbolicUnaryExecutionExtension : IPreExecuteInstructionExtension, IPostExecuteInstructionExtension
    {
        public abstract IEnumerable<Type> SupportedInstructions { get; }

        /// <summary>
        /// Gets the expression type which is created by this extension.
        /// </summary>
        public abstract ExpressionType ExpressionType { get; }

        IDataElement _value;

        public virtual void PreExecute(InstructionExecBase instruction, ExplicitActiveState cur)
        {
            _value = cur.EvalStack[cur.EvalStack.Length - 1];
        }


        public virtual void PostExecute(InstructionExecBase instruction, ExplicitActiveState cur, IIEReturnValue retValue)
        {
            if (_value.TryGetExpression(cur, out Expression valueExpr))
            {
                IDataElement result = cur.EvalStack.Peek();

                result.SetExpression(Expression.MakeUnary(ExpressionType, valueExpr, valueExpr.Type), cur);
            }
        }
    }
<#
    SymbolicOperationInfo[] infos = new SymbolicOperationInfo[]
    {
        new SymbolicOperationInfo("CGT", "GreaterThan", true, "CGT"),
        new SymbolicOperationInfo("CLT", "LessThan", true, "CLT"),
        // new SymbolicOperationInfo("CEQ", "Equal", true, "CEQ"), // CEQ is a special case - there are two posibilities how to handle it => done explicitly

        new SymbolicOperationInfo("ADD", "Add", true, "ADD", "ADD_OVF_UN"),
        new SymbolicOperationInfo("DIV", "Divide", true, "DIV"),
        new SymbolicOperationInfo("MUL", "Multiply", true, "MUL"),
        new SymbolicOperationInfo("REM", "Modulo", true, "REM"),
        new SymbolicOperationInfo("SUB", "Subtract", true, "SUB"),
        new SymbolicOperationInfo("NEG", "Negate", false, "NEG"),

        new SymbolicOperationInfo("AND", "And", true, "AND"),
        new SymbolicOperationInfo("NOT", "Not", false, "NOT"),
        new SymbolicOperationInfo("OR", "Or", true, "OR"),
        new SymbolicOperationInfo("XOR", "ExclusiveOr", true, "XOR"),
        new SymbolicOperationInfo("SHL", "LeftShift", true, "SHL"),
        new SymbolicOperationInfo("SHR", "RightShift", true, "SHR", "SHR_UN"),

        // TODO - extend UnarySymbolicExecutionExtension to accomodate more options, like specifying resulting type etc new SymbolicOperationInfo("CONV", "Convert", false, "Convert", "Conv_I", "Conv_I1", "Conv_I2")
    };
 #>

    public static class SymbolicExecutionFactoryExtensions
    {
        public static ExtendableInstructionFactory AddSymbolicExecution(this ExtendableInstructionFactory factory)
        {
<#
            foreach (string name in infos.Select(i => i.Name).Append("CEQ"))
            {
 #>
                factory.RegisterExtension(new <#= name #>_SymbolicExecutionExtension());
<#
            }
 #>     
            return factory;
        }
    
    }
    

    public class CEQ_SymbolicExecutionExtension : SymbolicBinaryExecutionExtension
    {
        public override IEnumerable<Type> SupportedInstructions
        {
            get { yield return typeof(CEQ); }
        }

        public override ExpressionType ExpressionType
        {
            get { return ExpressionType.Equal; }
        }

        public override void PostExecute(InstructionExecBase instruction, ExplicitActiveState cur, IIEReturnValue retValue)
        {
            // two posibilities
            // 1. (else branch) we are comparing two normal data elements => just do the default magic
            // 2. (if branch)   we are comparing a boolean value with zero (or possibly one if compiler is weird)
            //                  in other word we are doing negation / nothing over the iput value
            //                  only way to verify, which mode of execution is desired is if 
            //                    1) LHS is symbolic and its type is boolean
            //                    2) RHS is not symbolic
            //                  (this method is a bit dirty, but works thus far)
            if (Lhs.TryGetExpression(cur, out Expression lhsExpr) && !Rhs.TryGetExpression(cur, out Expression _) && lhsExpr.Type == typeof(bool))
            {
                IDataElement result = cur.EvalStack[cur.EvalStack.Length - 1];
                if (!Rhs.ToBool())
                {
                    result.SetExpression(Expression.MakeUnary(ExpressionType.Not, lhsExpr, typeof(bool)), cur);
                }
                else
                {
                    // weird compiler
                    result.SetExpression(lhsExpr, cur);
                }
            }
            else
            {
                base.PostExecute(instruction, cur, retValue);
            }
        }
    }

<#

    foreach (SymbolicOperationInfo i in infos)
    {
        if (i.IsBinary)
        {
 #>
    public class <#= i.Name #>_SymbolicExecutionExtension : SymbolicBinaryExecutionExtension
<#
        }
        else
        {
 #>
    public class <#= i.Name #>_SymbolicExecutionExtension : SymbolicUnaryExecutionExtension
<#
        }
 #>
    {
    
        public override IEnumerable<Type> SupportedInstructions
        {
            get
            {
<#
    foreach(string instructionType in i.AcceptedCodes)
    {
 #>
                yield return typeof(<#= instructionType #>);
<#
    }
 #>
            }
        }

        public override ExpressionType ExpressionType
        {
            get { return ExpressionType.<#= i.ExpressionType #>; }
        }
    }
<#
    }
 #>
}
<#+

readonly struct SymbolicOperationInfo
{
    public SymbolicOperationInfo(string name, string expressionType, bool isBinary, params string[] acceptedCodes)
    {
        Name = name;
        ExpressionType = expressionType;
        IsBinary = isBinary;
        AcceptedCodes = acceptedCodes;
    }

    public string Name { get; }
    public string[] AcceptedCodes { get; }
    public string ExpressionType { get; }
    public bool IsBinary { get; }
}

 #>